[
["2-Chapter2.html", "2 Data structures", " 2 Data structures Contrast how you see a fish and how computers see fish. Our job is to bridge the gap. No problem… In this chapter, we will introduce basic data structures and how to work with them in R. One of our challenges is to understand how R sees our data. R is what is known as a “high-level” or “interpreted” programming language, in addition to being “functional” and “object-oriented”. This means the pieces that make it up are a little more intuitive to the average user than most low-level languages like C or C++. The back-end of R is, in fact, a collection of low-level code that builds up the functionality that we need. This means that R has a broad range of uses, from data management to math, and even GIS and data visualization tools, all of which are conveniently wrapped in an “intuitive”, “user-friendly” language. Part of this flexibility comes from the fact that R is also a “vectorized” language. Holy cow, R is so many things. But, why do you care about this? This will help you wrap your head around how objects are created and stored in R, which will help you understand how to make, access, modify, and combine the data that you will need for any approach to data analysis. It is maybe easiest to see by taking a look at some of the data structures that we’ll work with. We will work exclusively with objects and functions created in base R for this Chapter, so you do not need any of the class data sets to play along. "],
["2-1-vectors.html", "2.1 Vectors", " 2.1 Vectors The vector is the basic unit of information in R. Pretty much everything else we’ll concern ourselves with is made of vectors and can be contained within one. Wow, what an existential paradox that is. Let’s take a look at how this works and why it matters. Here, we have defined a as a variable with the value of 1. a &lt;- 1 …or have we? print(a) ## [1] 1 What is the square bracket in the output here? It’s an index. The index is telling us that the first element of a is 1. This means that a is actually a “vector”, not a “scalar” or singular value as you may have been thinking about it. You can think of a vector as a column in an Excel spreadsheet or an analogous data table. By treating every object (loosely) as a vector, or an element thereof, the language becomes much more general. So, even if we define something with a single value, it is still just a vector with one element. For us, this is important because of the way that it lets us do math. It makes vector operations so easy that we don’t even need to think about them when we start to make statistical models. It makes working through the math a zillion times easier than on paper! In terms of programming, it can make a lot of things easier, too. An atomic vector is a vector that can hold one and only one kind of data. These can include: Character Numeric Integer Logical Factor Date/time And some others, but none with which we’ll concern ourselves here. If you are ever curious about what kind of object you are working with, you can find out by exposing the data structure with str(): Let’s go play with some! str(a) ## num 1 Examples of atomic vectors follow. Run the code to see what it does: Integers and numerics First, we demonstrate one way to make a vector in R. The c() function (“combine”) is our friend here for the quick-and-dirty approach. In this case, we are making an object that contains a sequence of whole numbers, or integers. # Make a vector of integers 1-5 a &lt;- c(1, 2, 3, 4, 5) # One way to look at our vector print(a) Here is another way to make the same vector, but we need to pay attention to how R sees the data type. A closer look shows that these methods produce a numeric vector (num) instead of an integer vector (int). For the most part, this one won’t make a huge difference, but it can become important when writing or debugging statistical models. # Define the same vector using a sequence a &lt;- seq(from = 1, to = 5, by = 1) str(a) ## num [1:5] 1 2 3 4 5 We can change this by explicitly telling R how to build our vector: a &lt;- as.vector(x = seq(1, 5, 1), mode = &quot;numeric&quot;) Notice that I did not include the argument names in the call to seq() because these are commonly used default arguments. Characters and factors Characters are anything that is represented as text strings. b &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) # Make a character vector b # Print it to the console ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; str(b) # Now it&#39;s a character vector ## chr [1:5] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; They are readily converted (sometimes automatically) to factors: b &lt;- as.factor(b) # But we can change if we want b ## [1] a b c d e ## Levels: a b c d e str(b) # Look at the data structure ## Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5 Factors are a special kind of data type in R that we may run across from time to time. They have levels that can be ordered numerically. This is not important except that it becomes useful for coding variables used in statistical models- R does most of this behind the scenes and we won’t have to worry about it for the most part. In fact, in a lot of cases we will want to change factors to numerics or characters so they are easier to manipulate. This is what it looks like when we code a factor as number: as.numeric(b) # What did that do? ?as.numeric Aside: we can ask R what functions mean by adding a question mark as we do above. And not just functions: we can ask it about pretty much any built-in object. The help pages take a little getting used to, but once you get the hang of it… In the mean time, the internet is your friend and you will find a multitude of online groups and forums with a quick search. Logical vectors Most of the logical vectors we deal with are yes/no or comparisons to determine whether a given piece of information matches a condition. Here, we use a logical check to see if the object a we created earlier is the same as object b. If we store the results of this check to a new object c, we get a new logical vector filled with TRUE and FALSE, one for each element in a and b. # The &quot;==&quot; compares the numeric vector to the factor one c &lt;- a == b c ## [1] FALSE FALSE FALSE FALSE FALSE str(c) ## logi [1:5] FALSE FALSE FALSE FALSE FALSE We now have a logical vector. For the sake of demonstration, we could perform any number of logical checks on a vector using built-in R functions (it does not need to be a logical like c above). We can check for missing values. is.na(a) ## [1] FALSE FALSE FALSE FALSE FALSE We can make sure that all values are finite. is.finite(a) ## [1] TRUE TRUE TRUE TRUE TRUE The exclamation ! point means “not” in to computers. !is.na(a) ## [1] TRUE TRUE TRUE TRUE TRUE We can see if specific elements meet a criterion. a == 3 ## [1] FALSE FALSE TRUE FALSE FALSE We can just look at unique values. unique(b) ## [1] a b c d e ## Levels: a b c d e The examples above are all simple vector operations. These form the basis for data manipulation and analysis in R. "],
["2-2-operations.html", "2.2 Vector operations", " 2.2 Vector operations A lot of data manipulation in R is based on logical checks like the ones shown above. We can take these one step further to actually perform what one might think of as a query. For example, we can reference specific elements of vectors directly. Here, we specify that we want to print the third element of a. # This one just prints it a[3] ## [1] 3 We might want to store that value to a new object f that is easier to read and type out. # This one stores it in a new object f &lt;- a[3] Important If it is not yet obvious, we have to assign the output of functions to new objects for the values to be usable in the future. In the example above, a is never actually changed. This is a common source of confusion early on. Going further, we could select vector elements based on some condition. On the first line of code, we tell R to show us the indices of the elements in vector b that match the character string c. Out loud, we would say, “b where the value of b is equal to c” in the first example. We can also use built-in R functions to just store the indices for all elements of b where b is equal to the character string “c”. b[b == &quot;c&quot;] ## [1] c ## Levels: a b c d e which(b == &quot;c&quot;) ## [1] 3 Perhaps more practically speaking, we can do elementwise operations on vectors easily in R. Here are a bunch of different things that you might be interested in doing with the objects that we’ve created so far. Give a few of these a try. Perhaps more practically speaking, we can do elementwise operations on vectors easily in R. Give a few of these a shot. a * .5 # Multiplication a + 100 # Addition a - 3 # Subtraction a / 2 # Division a^2 # Exponentiation exp(a) # Same as &quot;e to the a&quot; log(a) # Natural logarithm log10(a) # Log base 10 If we change b to character, we can do string manipulation, too! # Convert b to character b &lt;- as.character(b) We can append text. Remember, the examples below will just print the result. We would have to overwrite b or save it to a new object if we wanted to be able to use the result somewhere else later. # Paste an arbitrary string on to b paste(b, &quot;AAAA&quot;, sep = &quot;&quot;) ## [1] &quot;aAAAA&quot; &quot;bAAAA&quot; &quot;cAAAA&quot; &quot;dAAAA&quot; &quot;eAAAA&quot; # We can do it the other way paste(&quot;AAAA&quot;, b, sep = &quot;&quot;) ## [1] &quot;AAAAa&quot; &quot;AAAAb&quot; &quot;AAAAc&quot; &quot;AAAAd&quot; &quot;AAAAe&quot; # Add symbols to separate paste(&quot;AAAA&quot;, b, sep = &quot;--&quot;) ## [1] &quot;AAAA--a&quot; &quot;AAAA--b&quot; &quot;AAAA--c&quot; &quot;AAAA--d&quot; &quot;AAAA--e&quot; # We can replace text gsub(pattern = &quot;c&quot;, replacement = &quot;AAAA&quot;, b) ## [1] &quot;a&quot; &quot;b&quot; &quot;AAAA&quot; &quot;d&quot; &quot;e&quot; # Make a new object e &lt;- paste(&quot;AAAA&quot;, b, sep = &quot;&quot;) # Print to console e ## [1] &quot;AAAAa&quot; &quot;AAAAb&quot; &quot;AAAAc&quot; &quot;AAAAd&quot; &quot;AAAAe&quot; # We can strip text # (or dates, or times, etc.) substr(e, start = 5, stop = 5) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; We can check how many elements are in a vector. # A has a length of 5, # try it and check it length(a) ## [1] 5 # Yup, looks about right a ## [1] 1 2 3 4 5 And we can do lots of other nifty things like this. We can also bind multiple vectors together into a rectangular matrix. Say what? "],
["2-3-matrices.html", "2.3 Matrices", " 2.3 Matrices Matrices are rectangular objects that we can think of as being made up of vectors. We can make matrices by binding vectors that already exist. cbind(a, e) ## a e ## [1,] &quot;1&quot; &quot;AAAAa&quot; ## [2,] &quot;2&quot; &quot;AAAAb&quot; ## [3,] &quot;3&quot; &quot;AAAAc&quot; ## [4,] &quot;4&quot; &quot;AAAAd&quot; ## [5,] &quot;5&quot; &quot;AAAAe&quot; Or we can make an empty one to fill. matrix(0, nrow = 3, ncol = 4) ## [,1] [,2] [,3] [,4] ## [1,] 0 0 0 0 ## [2,] 0 0 0 0 ## [3,] 0 0 0 0 Or we can make one from scratch. mat &lt;- matrix(seq(1, 12), ncol = 3, nrow = 4) We can do all of the things we did with vectors to matrices, but now we have more than one column, and official “rows” that we can also use to these ends: ncol(mat) # Number of columns nrow(mat) # Number of rows length(mat) # Total number of entries mat[2, 3] # Value of row 2, column 3 str(mat) See how number of rows and columns is defined in data structure? With rows and columns, we can assign column names and row names. colnames(mat) &lt;- c(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;) rownames(mat) &lt;- c(&quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;matrix&quot;) # Take a look mat ## first second third ## This 1 5 9 ## is 2 6 10 ## a 3 7 11 ## matrix 4 8 12 We can also do math on matrices just like vectors, because matrices are just vectors smooshed into two dimensions (it’s totally a word). mat * 2 ## first second third ## This 2 10 18 ## is 4 12 20 ## a 6 14 22 ## matrix 8 16 24 All the same operations we did on vectors above…one example. More on matrices as we need them. We won’t use these a lot in this module, but R relies heavily on matrices to do linear algebra behind the scenes in the models that we will be working with. "],
["2-4-dataframes.html", "2.4 Dataframes", " 2.4 Dataframes Dataframes are like matrices, only not. They have a row/column structure like matrices and are also rectangular in nature. But, they can hold more than one data type! Dataframes are made up of atomic vectors. This is probably the data structure that we will use most in this book, along with atomic vectors. Let’s make a dataframe to see how it works. # Make a new object &#39;a&#39; from a sequence a &lt;- seq(from = .5, to = 10, by = .5) # Vector math: raise each &#39;a&#39; to power of 2 b &lt;- a^2 # Replicates values in object a # of times c &lt;- rep(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;), 5) # Note, we don&#39;t use quotes for objects, # but we do for character variables d &lt;- data.frame(a, b, c) Now we can look at it: print(d) ## a b c ## 1 0.5 0.25 a ## 2 1.0 1.00 b ## 3 1.5 2.25 c ## 4 2.0 4.00 d ## 5 2.5 6.25 a ## 6 3.0 9.00 b ## 7 3.5 12.25 c ## 8 4.0 16.00 d ## 9 4.5 20.25 a ## 10 5.0 25.00 b ## 11 5.5 30.25 c ## 12 6.0 36.00 d ## 13 6.5 42.25 a ## 14 7.0 49.00 b ## 15 7.5 56.25 c ## 16 8.0 64.00 d ## 17 8.5 72.25 a ## 18 9.0 81.00 b ## 19 9.5 90.25 c ## 20 10.0 100.00 d Notice that R assigns names to dataframes on the fly based on object names that you used to create them unless you specify elements of a data frame like this. They are not colnames as with matrices, they are names. You can set them when you make the dataframe like this: d &lt;- data.frame(a = a, b = b, c = c) Now can look at the names. # All of the names names(d) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # One at a time: note indexing, names(d) is a vector!! names(d)[2] ## [1] &quot;b&quot; We can change the names. # All at once- note quotes names(d) &lt;- c(&quot;Increment&quot;, &quot;Squared&quot;, &quot;Class&quot;) # Print it to see what this does names(d) # Or, change one at a time.. names(d)[3] &lt;- &quot;Letter&quot; # Print it again to see what changed names(d) We can also rename the entire dataframe. e &lt;- d Have a look: # Head shows first six # rows by default head(e) ## a b c ## 1 0.5 0.25 a ## 2 1.0 1.00 b ## 3 1.5 2.25 c ## 4 2.0 4.00 d ## 5 2.5 6.25 a ## 6 3.0 9.00 b # Or, we can look at any # other number that we want head(e, 10) ## a b c ## 1 0.5 0.25 a ## 2 1.0 1.00 b ## 3 1.5 2.25 c ## 4 2.0 4.00 d ## 5 2.5 6.25 a ## 6 3.0 9.00 b ## 7 3.5 12.25 c ## 8 4.0 16.00 d ## 9 4.5 20.25 a ## 10 5.0 25.00 b We can make new columns in data frames like this! # Make a new column with the # square root of our increment # column e$Sqrt &lt;- sqrt(e$Increment) e Looking at specific elements of a dataframe is similar to a matrix, with some added capabilities. We’ll do this with a real data set so it’s more fun. There are a whole bunch of built-in data sets that we can use for examples. Let’s start by looking at the iris data. # This is how you load built-in # data sets data(&quot;iris&quot;) Play with the functions below to explore how this data set is stored in the environment, and how R sees it. This is a good practice to get into in general. # We can use ls() to see # what is in our environment ls() # Look at the first six rows # of data in the object head(iris) # How many rows does it have? nrow(iris) # How many columns? ncol(iris) # What are the column names? names(iris) # Have a look at the data structure- # tells us all of the above str(iris) # Summarize the variables # in the dataframe summary(iris) Now let’s look at some specific things. # What is the value in 12th row # of the 4th column of iris? iris[12, 4] ## [1] 0.2 # What is the mean sepal length # among all species in iris? mean(iris$Sepal.Length) ## [1] 5.843333 What about the mean of Sepal.Length just for setosa? A couple of new things going on here: We can refer to the columns as atomic vectors within the dataframe if we want to. Some times we have to do this… Note the logical check for species What we are saying here is, “Hey R, show me the mean of the column Sepal.Length in the dataframe iris where the species name is setosa” mean(iris$Sepal.Length[iris$Species == &quot;setosa&quot;]) ## [1] 5.006 We can write this out longhand to make sure it’s correct (it is). logicalCheck &lt;- iris$Species == &quot;setosa&quot; lengthCheck &lt;- iris$Sepal.Length[iris$Species == &quot;setosa&quot;] We can also look at the whole data frame just for setosa. # Note that the structure of species # is preserved as a factor with three # levels even though setosa is the # only species name in the new df setosaData &lt;- iris[iris$Species == &quot;setosa&quot;, ] str(setosaData) ## &#39;data.frame&#39;: 50 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... Finally, once we are working with dataframes, plotting becomes much easier to understand, and we can ease into some rudimentary, clunky R plots. # Some quick plotting code # Once we have a nice dataframe like # these ones, we can actually step into # The world of exploratory analyses. # Make a histogram of sepal lengths hist(setosaData$Sepal.Length) # Bi-plot plot(setosaData$Sepal.Width, setosaData$Sepal.Length) # Boxplots boxplot(Sepal.Width ~ Species, data = iris) Much, MUCH more of this to come as we continue. "],
["2-5-lists.html", "2.5 Lists", " 2.5 Lists Lists are the ultimate data type in R. They are actually a vector that can hold different kinds of data, like a dataframe. In fact, a dataframe is just a spectacularly rectangular list. Each element of a list can be any kind of object (an atomic vector, a matrix, a dataframe, or even another list!!). Most of the real, filthy R programming relies heavily on lists. We will have to work with them at some point in this class, but we won’t take a ton of time on them here. Let’s make a list- just to see how they work. Notice how our index operator has changed from [ ] to [[ ]]? And, at the highest level of organization, we have only one dimension in our list, but any given element myList[[i]] could hold any number of dimensions. # Create an empty list with four elements myList &lt;- vector(mode = &quot;list&quot;, length = 4) # Assign some of our previously # created objects to the elements myList[[1]] &lt;- a myList[[2]] &lt;- c myList[[3]] &lt;- mat myList[[4]] &lt;- d Have a look at the list: # Print it # Cool, huh? myList ## [[1]] ## [1] 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 ## [16] 8.0 8.5 9.0 9.5 10.0 ## ## [[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; ## [20] &quot;d&quot; ## ## [[3]] ## first second third ## This 1 5 9 ## is 2 6 10 ## a 3 7 11 ## matrix 4 8 12 ## ## [[4]] ## a b c ## 1 0.5 0.25 a ## 2 1.0 1.00 b ## 3 1.5 2.25 c ## 4 2.0 4.00 d ## 5 2.5 6.25 a ## 6 3.0 9.00 b ## 7 3.5 12.25 c ## 8 4.0 16.00 d ## 9 4.5 20.25 a ## 10 5.0 25.00 b ## 11 5.5 30.25 c ## 12 6.0 36.00 d ## 13 6.5 42.25 a ## 14 7.0 49.00 b ## 15 7.5 56.25 c ## 16 8.0 64.00 d ## 17 8.5 72.25 a ## 18 9.0 81.00 b ## 19 9.5 90.25 c ## 20 10.0 100.00 d You can assign names when you create the list like we did for dataframes, too. You can do this manually, or R will do it on the fly for you. You can also reassign names to a list that yo’ve already created. # No names by default names(myList) # Give it names like we did with # a dataframe names(myList) &lt;- c(&quot;a&quot;, &quot;c&quot;, &quot;mat&quot;, &quot;d&quot;) # See how the names work now? myList # We reference these differently [[]] myList[[1]] # But we can still get into each object # Play around with the numbers to see what they do! myList[[2]][5] # Can also reference it this way! myList$c[1] Very commonly, model objects and output are stored as lists. In fact, most objects that require a large amount of diverse information in R pack it all together in one place using lists, that way we always know where to find it and how as long as the objects are documented. Conceptually, every object in R, from your workspace on down the line, is a list AND an element of a list. It seems like a lot to take in now, but will be very useful in the future. "],
["2-6-next2.html", "2.6 Next steps", " 2.6 Next steps For more practice with the data structures and R functions we covered here, you can check out this walk-through of basic R commands from the How To R YouTube Channel. In the Chapter 3(#Chapter3), we will begin using functions from external R packages to read and work with real data. "]
]
